#!/usr/bin/env python3

"""
KiCad to SKiDL Converter

This script converts KiCad v8 schematics (.kicad_sch files) into SKiDL Python code.
"""

import sys
import re
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple
from dataclasses import dataclass
from collections import defaultdict

DEBUG = True

def debug_print(msg: str):
    """Print debug messages if DEBUG is enabled"""
    if DEBUG:
        print(f"DEBUG: {msg}")

@dataclass
class Pin:
    """Represents a pin on a component"""
    number: str
    name: str
    type: str
    uuid: str
    net: Optional[str] = None

@dataclass
class Part:
    """Represents a component in the schematic"""
    lib_id: str
    reference: str
    value: str
    footprint: Optional[str]
    uuid: str
    unit: int = 1
    on_board: bool = True
    in_bom: bool = True

class KicadSchematicParser:
    """Parser for KiCad schematic files"""
    
    def __init__(self, filename: str):
        self.filename = filename
        self.parts: Dict[str, Part] = {}  # UUID -> Part
        self.nets: Dict[str, List[Tuple[str, str]]] = defaultdict(list)  # Net name -> [(part_ref, pin_num)]
        debug_print(f"Initializing parser for file: {filename}")
        self._parse_file()

    def _parse_file(self):
        """Parse the KiCad schematic file"""
        debug_print("Starting schematic file parsing")
        
        try:
            with open(self.filename, 'r') as f:
                content = f.read()
                debug_print(f"Successfully read file, content length: {len(content)}")
        except Exception as e:
            print(f"Error reading file: {str(e)}")
            return

        # Extract symbol instances
        debug_print("Parsing symbol instances...")
        symbol_matches = re.finditer(r'\(symbol.*?\n\s*\)', content, re.DOTALL)
        for match in symbol_matches:
            self._parse_symbol(match.group(0))
            
    def _parse_symbol(self, content: str):
        """Parse a symbol instance"""
        # Extract basic information
        lib_id_match = re.search(r'\(lib_id "([^"]+)"', content)
        reference_match = re.search(r'\(property "Reference" "([^"]+)"', content)
        value_match = re.search(r'\(property "Value" "([^"]+)"', content)
        footprint_match = re.search(r'\(property "Footprint" "([^"]+)"', content)
        uuid_match = re.search(r'\(uuid ([^\s\)]+)', content)
        unit_match = re.search(r'\(unit (\d+)\)', content)
        
        if lib_id_match and reference_match and uuid_match:
            lib_id = lib_id_match.group(1)
            reference = reference_match.group(1)
            value = value_match.group(1) if value_match else ''
            footprint = footprint_match.group(1) if footprint_match else None
            uuid = uuid_match.group(1)
            unit = int(unit_match.group(1)) if unit_match else 1
            
            debug_print(f"Found part: {reference} ({lib_id})")
            
            # Create part
            self.parts[uuid] = Part(
                lib_id=lib_id,
                reference=reference,
                value=value,
                footprint=footprint,
                uuid=uuid,
                unit=unit
            )

class SkidlCodeGenerator:
    """Generate SKiDL code from parsed KiCad schematic"""
    
    def __init__(self, parser: KicadSchematicParser):
        self.parser = parser

    def generate(self) -> str:
        """Generate SKiDL code"""
        debug_print("Starting SKiDL code generation")
        
        code = [
            "from skidl import *\n",
            "from skidl.pyspice import *\n\n",
            "# Generated by KiCad to SKiDL converter\n\n",
            "# Create a default circuit\n",
            "circ = Circuit()\n\n"
        ]
        
        # Create parts
        code.append("# Instantiate parts\n")
        for part in self.parser.parts.values():
            lib_id = part.lib_id.split(':')
            if len(lib_id) == 2:
                library, part_name = lib_id
                var_name = part.reference.lower()
                
                # Handle special cases for basic components
                if part_name == 'R':
                    code.append(f"{var_name} = Part('Device', 'R', value='{part.value}')\n")
                elif part_name == 'C':
                    code.append(f"{var_name} = Part('Device', 'C', value='{part.value}')\n")
                else:
                    code.append(f"{var_name} = Part('{library}', '{part_name}', value='{part.value}')\n")
                
                if part.footprint:
                    code.append(f"{var_name}.footprint = '{part.footprint}'\n")
                    
                debug_print(f"Generated code for part: {part.reference}")
        
        code.append("\n# Generate netlist\n")
        code.append("generate_netlist()")
        
        result = "".join(code)
        debug_print("Code generation complete")
        return result

def convert_kicad_to_skidl(input_file: str, output_file: str):
    """Convert a KiCad schematic to SKiDL code"""
    print(f"Starting conversion of {input_file} to {output_file}")
    
    # Parse KiCad schematic
    parser = KicadSchematicParser(input_file)
    
    # Generate SKiDL code
    generator = SkidlCodeGenerator(parser)
    skidl_code = generator.generate()
    
    # Write output file
    with open(output_file, 'w') as f:
        f.write(skidl_code)
    
    print(f"Successfully converted {input_file} to {output_file}")

def main():
    if len(sys.argv) != 3:
        print("Usage: kicad_to_skidl.py input.kicad_sch output.py")
        sys.exit(1)
        
    input_file = sys.argv[1]
    output_file = sys.argv[2]
    
    try:
        convert_kicad_to_skidl(input_file, output_file)
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()