#!/usr/bin/env python3

#==============================================================================
# QUICK EDIT CONFIGURATION - Modify these values as needed
#==============================================================================

# Where to look for files
ROOT_DIRECTORY = "/Users/shanemattner/Desktop/skidl"

# Where to save the combined output
OUTPUT_FILE = "collected_code.txt"

# What files to collect (add or remove filenames as needed)
TARGET_FILES = [
    'PLANNING_DOC.md',
    '_3v3_regulator.py',
    'resistor_divider.py',
    'esp32s3mini1.py',
    'USB.py',
    'netlist_to_skidl.py',
    'main.net',
    'example_kicad_project.net',
    'report.txt',
]

# Message to add at the start of the output file
INTRO_MESSAGE = """
KiCad Netlist to SKiDL Converter Code Collection

This combined output contains all implementation files for the KiCad-to-SKiDL converter tool, preserving the exact 1:1 mapping between KiCad schematics and generated Python code as outlined in PLANNING_DOC.md.

File Overview:

1. PLANNING_DOC.md - Core design document specifying:
   - 1:1 schematic/code correspondence
   - Net naming conversion rules
   - Hierarchical preservation requirements
   - Component handling specifications

2. netlist_to_skidl.py - Main conversion script implementing:
   - KiCad netlist parsing (using kinparse)
   - Hierarchical sheet structure preservation
   - Python-safe net name conversion
   - Exact component replication with properties

3. Generated Circuit Modules (auto-generated by converter):
   - _3v3_regulator.py: Voltage regulation subcircuit
   - resistor_divider.py: Resistive voltage divider implementation
   - esp32s3mini1.py: ESP32-S3-MINI-1 module interface
   - USB.py: USB connector and interface circuitry
   - main.py: listed below

4. report.txt: Kicad PCB import logs trying to import main.net

Key Implementation Details:
- Strict 1:1 mapping between KiCad sheets and Python modules
- All nets explicitly passed through hierarchy
- Original component references preserved (C10, R9, etc)
- No automatic optimization - exact topology maintained
- Generated code matches KiCad structure at all levels

Note: main.py files are excluded from this collection to prevent accidental inclusion of multiple entry points. The converter generates standalone modules that can be imported into a top-level circuit design.

Here is main.py:

# -*- coding: utf-8 -*-
from skidl import *
from esp32s3mini1 import esp32s3mini1
from _3v3_regulator import _3v3_regulator
from resistor_divider1 import resistor_divider1
from USB import USB

def main():
    # Create nets
    _p_3V3 = Net('+3V3')
    _p_5V = Net('+5V')
    _3v3_monitor = Net('3v3_monitor')
    _5v_monitor = Net('5v_monitor')
    D_p = Net('D+')
    D_n = Net('D-')
    esp32s3mini1_HW_VER = Net('esp32s3mini1/HW_VER')
    GND = Net('GND')

    # Create subcircuits
    esp32s3mini1(_p_3V3, _3v3_monitor, _5v_monitor, D_p, D_n, esp32s3mini1_HW_VER, GND)
    _3v3_regulator(_p_3V3, _p_5V, _3v3_monitor, _5v_monitor, GND)
    USB(_p_5V, D_p, D_n, GND)

if __name__ == "__main__":
    main()
    generate_netlist()


______

TODO:
- Help me change logic in netlist_to_skidl.py to make the resistor_divider1.py file a child of the esp32s3mini1.py file as it is in the kicad netlist file example_kicad_project.net
So the esp32s3mini1.py file should look like this:

# -*- coding: utf-8 -*-
from skidl import *

@subcircuit
def esp32s3mini1(_p_3V3, _3v3_monitor, _5v_monitor, D_p, D_n, esp32s3mini1_HW_VER, GND):
    # Components
    C1 = Part('Device', 'C', value='10uF', footprint='Capacitor_SMD:C_0603_1608Metric', tag='C1', Sheetname='esp32s3mini1', Sheetfile='esp32s3mini1.kicad_sch', ki_keywords='cap capacitor', ki_fp_filters='C_*')
    J1 = Part('Connector_Generic', 'Conn_02x03_Odd_Even', value='Conn_02x03_Odd_Even', footprint='Connector_IDC:IDC-Header_2x03_P2.54mm_Vertical', tag='J1', Sheetname='esp32s3mini1', Sheetfile='esp32s3mini1.kicad_sch', ki_keywords='connector', ki_fp_filters='Connector*:*_2x??_*')
    U3 = Part('RF_Module', 'ESP32-S3-MINI-1', value='ESP32-S3-MINI-1', footprint='RF_Module:ESP32-S2-MINI-1', tag='U3', Sheetname='esp32s3mini1', Sheetfile='esp32s3mini1.kicad_sch', ki_keywords='RF Radio BT ESP ESP32-S3 Espressif', ki_fp_filters='ESP32?S*MINI?1')

    # Local nets
    esp32s3mini1_EN = Net('esp32s3mini1/EN')
    esp32s3mini1_IO0 = Net('esp32s3mini1/IO0')
    esp32s3mini1_RX = Net('esp32s3mini1/RX')
    esp32s3mini1_TX = Net('esp32s3mini1/TX')
    esp32s3mini1_HW_VER = Net('esp32s3mini1/HW_VER')


    # Hierarchical subcircuits
    resistor_divider1(_p_3V3, esp32s3mini1_HW_VER, GND)


    # Connections
    _p_3V3 += C1['1'], J1['2'], U3['3']
    _3v3_monitor += U3['6']
    _5v_monitor += U3['7']
    D_p += U3['24']
    D_n += U3['23']
    esp32s3mini1_EN += J1['1'], U3['45']
    esp32s3mini1_HW_VER += U3['5']
    esp32s3mini1_IO0 += J1['6'], U3['4']
    esp32s3mini1_RX += J1['5'], U3['40']
    esp32s3mini1_TX += J1['3'], U3['39']
    GND += C1['2'], J1['4'], U3['1'], U3['2'], U3['42'], U3['43'], U3['46'], U3['47'], U3['48'], U3['49'], U3['50'], U3['51'], U3['52'], U3['53'], U3['54'], U3['55'], U3['56'], U3['57'], U3['58'], U3['59'], U3['60'], U3['61'], U3['62'], U3['63'], U3['64'], U3['65']

_________
and here is how main.py should look:

# -*- coding: utf-8 -*-
from skidl import *
from esp32s3mini1 import esp32s3mini1
from _3v3_regulator import _3v3_regulator
from USB import USB

def main():
    # Create nets
    _p_3V3 = Net('+3V3')
    _p_5V = Net('+5V')
    _3v3_monitor = Net('3v3_monitor')
    _5v_monitor = Net('5v_monitor')
    D_p = Net('D+')
    D_n = Net('D-')
    GND = Net('GND')

    # Create subcircuits
    esp32s3mini1(_p_3V3, _3v3_monitor, _5v_monitor, D_p, D_n, esp32s3mini1_HW_VER, GND)
    _3v3_regulator(_p_3V3, _p_5V, _3v3_monitor, _5v_monitor, GND)
    USB(_p_5V, D_p, D_n, GND)

if __name__ == "__main__":
    main()
    generate_netlist()


"""

#==============================================================================
# Script Implementation - No need to modify below this line
#==============================================================================

"""and
File Collector for Query Building

This script combines specific files into a single output file to help build
queries when iterating on software development. Edit the CONFIGURATION section
at the top to customize which files to collect.
"""

import os
from typing import List
from dataclasses import dataclass

@dataclass
class FileCollectorConfig:
    """Configuration class to store all script parameters"""
    root_directory: str
    output_filename: str
    target_filenames: List[str]
    intro_message: str

def create_config_from_settings() -> FileCollectorConfig:
    """Creates configuration object from the settings defined at the top of the script"""
    return FileCollectorConfig(
        root_directory=ROOT_DIRECTORY,
        output_filename=OUTPUT_FILE,
        target_filenames=TARGET_FILES,
        intro_message=INTRO_MESSAGE
    )

def is_target_file(filename: str, target_files: List[str]) -> bool:
    """
    Check if a filename matches one of our target filenames.
    
    Args:
        filename: Name of the file to check
        target_files: List of target filenames to match against
    """
    return os.path.basename(filename) in target_files

def find_target_files(config: FileCollectorConfig) -> List[str]:
    """
    Search for target files in the root directory.
    
    Args:
        config: Configuration object containing search parameters
    
    Returns:
        List[str]: List of full file paths for matching files
    """
    collected_files = []
    
    # Walk through the directory tree
    for dirpath, _, filenames in os.walk(config.root_directory):
        for filename in filenames:
            if is_target_file(filename, config.target_filenames):
                full_path = os.path.join(dirpath, filename)
                if os.path.isfile(full_path):
                    collected_files.append(full_path)
    
    return sorted(collected_files)

def write_combined_file(collected_files: List[str], config: FileCollectorConfig) -> None:
    """
    Write all collected file contents to a single output file.
    
    Args:
        collected_files: List of file paths to combine
        config: Configuration object containing output settings
    """
    with open(config.output_filename, 'w') as out_file:
        # Write the introduction message
        out_file.write(config.intro_message + "\n")
        
        # Process each collected file
        total_lines = 0
        for file_path in collected_files:
            try:
                # Read and write each file's contents with clear separation
                with open(file_path, 'r') as input_file:
                    content = input_file.read()
                    filename = os.path.basename(file_path)
                    
                    # Add clear separators around file content
                    out_file.write(f"\n/* Begin of file: {filename} */\n")
                    out_file.write(content)
                    out_file.write(f"\n/* End of file: {filename} */\n")
                    
                    # Print statistics for monitoring
                    num_lines = len(content.splitlines())
                    total_lines += num_lines
                    print(f"{filename}: {num_lines} lines")
                    
            except Exception as e:
                print(f"Error processing {file_path}: {e}")
        print(f"Total lines written: {total_lines}")

def main():
    """Main execution function"""
    # Create configuration from settings
    config = create_config_from_settings()
    
    # Find all matching files
    collected_files = find_target_files(config)
    
    # Combine files into output
    write_combined_file(collected_files, config)
    
    # Print summary
    print(f"\nProcessed {len(collected_files)} files")
    print(f"Output saved to: {config.output_filename}")

if __name__ == "__main__":
    main()
