#!/usr/bin/env python3

#==============================================================================
# QUICK EDIT CONFIGURATION - Modify these values as needed
#==============================================================================

# Where to look for files
ROOT_DIRECTORY = "/Users/shanemattner/Desktop/skidl/kicad_schematic_parser"

# Where to save the combined output
OUTPUT_FILE = "query.txt"

# What files to collect (add or remove filenames as needed)
TARGET_FILES = [
    'kiutils_test.py',
    'labels_testing.kicad_sch',
    'labels_testing_output.txt',
]

# Message to add at the start of the output file
INTRO_MESSAGE = """The following files are part of a software project:
This collection of files for a circuit design tool includes Python scripts and KiCad schematic files.

Core Files:
- kiutils_test.py: Python script for analyzing KiCad schematic files
- labels_testing.kicad_sch: Example KiCad schematic top level file that has labels connected to each other
- labels_testing_output.txt: Output file generated by kiutils_test.py for a KiCad schematic file


This logic works well but needs to be refactored to handle more complex cases.  I recently implemented logic to combine labels and it has a few bugs.
:
- R12 pin 2 is not connected to anything, it should be connected to 3v3_monitor or divider_2
- Power labels have duplicate entries in Netlist section under `Connected Labels`
- divider_1 should be connected to 5v_monitor, which means J3 pin 3 should be connected to 5v_monitor
- divider_2 should be connected to 3v3_monitor, which means J3 pin 4 should be connected to 3v3_monitor
- label_test_powerx nets are listed as connected to themselves under `Connected Labels`, this is a duplicate entry since they are already connected to other labels
- R9 pin 2 is not connected to anything, it should be connected to 5v_monitor or divider_1
- R11 pin 1 is not connected to anything, it should be connected to 3v3_monitor or divider_2

For reference, in the output file attached:
- `lbael_test_power1` is connected to +5v so it should take on that net name when connecting to other parts
- `label_test_power4` is connected to `label_test_power1` so it should take on the net name of `label_test_power1`, which will be +5v after conversion
- `label_test_power3` is connected to GND so it should take on that net name when connecting to other parts
- `divider_2` connects to `3v3_monitor` hierarchical label so it should take on the net name of `3v3_monitor` which will be +3v3 after conversion

It is possible to have many different labels connected to each other, so the logic needs to be able to handle any combination of labels a pin might be attached to.

Keep the logic as simple as possible.  Increase the amount of data you are collecting and processing to make the logic more robust. ie if there are 5 labels
connected to eachother then perhaps a pin is listed 5 times in the output file, once for each label it is connected to.  This will make it easier and more robust.
We can refactor for more intelligent code later

Please ask questions if you need more information or examples
"""

#==============================================================================
# Script Implementation - No need to modify below this line
#==============================================================================

"""
File Collector for Query Building

This script combines specific files into a single output file to help build
queries when iterating on software development. Edit the CONFIGURATION section
at the top to customize which files to collect.
"""

import os
from typing import List
from dataclasses import dataclass

@dataclass
class FileCollectorConfig:
    """Configuration class to store all script parameters"""
    root_directory: str
    output_filename: str
    target_filenames: List[str]
    intro_message: str

def create_config_from_settings() -> FileCollectorConfig:
    """Creates configuration object from the settings defined at the top of the script"""
    return FileCollectorConfig(
        root_directory=ROOT_DIRECTORY,
        output_filename=OUTPUT_FILE,
        target_filenames=TARGET_FILES,
        intro_message=INTRO_MESSAGE
    )

def is_target_file(filename: str, target_files: List[str]) -> bool:
    """
    Check if a filename matches one of our target filenames.
    
    Args:
        filename: Name of the file to check
        target_files: List of target filenames to match against
    """
    return os.path.basename(filename) in target_files

def find_target_files(config: FileCollectorConfig) -> List[str]:
    """
    Search for target files in the root directory, ignoring files in 'tests' folders.
    
    Args:
        config: Configuration object containing search parameters
    
    Returns:
        List[str]: List of full file paths for matching files
    """
    collected_files = []
    
    # Walk through the directory tree
    for dirpath, _, filenames in os.walk(config.root_directory):
        # Skip if 'tests' is in the directory path
        if 'tests' in dirpath.split(os.sep):
            continue
            
        for filename in filenames:
            if is_target_file(filename, config.target_filenames):
                full_path = os.path.join(dirpath, filename)
                if os.path.isfile(full_path):
                    collected_files.append(full_path)
    
    return sorted(collected_files)

def write_combined_file(collected_files: List[str], config: FileCollectorConfig) -> None:
    """
    Write all collected file contents to a single output file.
    
    Args:
        collected_files: List of file paths to combine
        config: Configuration object containing output settings
    """
    with open(config.output_filename, 'w') as out_file:
        # Write the introduction message
        out_file.write(config.intro_message + "\n")
        
        # Process each collected file
        total_lines = 0
        for file_path in collected_files:
            try:
                # Read and write each file's contents with clear separation
                with open(file_path, 'r') as input_file:
                    content = input_file.read()
                    filename = os.path.basename(file_path)
                    
                    # Add clear separators around file content
                    out_file.write(f"\n/* Begin of file: {filename} */\n")
                    out_file.write(content)
                    out_file.write(f"\n/* End of file: {filename} */\n")
                    
                    # Print statistics for monitoring
                    num_lines = len(content.splitlines())
                    total_lines += num_lines
                    print(f"{filename}: {num_lines} lines")
                    
            except Exception as e:
                print(f"Error processing {file_path}: {e}")
        print(f"Total lines written: {total_lines}")

def main():
    """Main execution function"""
    # Create configuration from settings
    config = create_config_from_settings()
    
    # Find all matching files
    collected_files = find_target_files(config)
    
    # Combine files into output
    write_combined_file(collected_files, config)
    
    # Print summary
    print(f"\nProcessed {len(collected_files)} files")
    print(f"Output saved to: {config.output_filename}")

if __name__ == "__main__":
    main()
