The following files are part of a software project:
This collection of files for a circuit design tool includes Python scripts and KiCad schematic files.

Core Files:
- kiutils_test.py: Python script for analyzing KiCad schematic files
- example_kicad_project.kicad_sch: Example KiCad schematic top level file that has hierarchical schematic sheets
- example_kicad_project_output.txt: Output file generated by kiutils_test.py for a KiCad schematic file


The logic works for calculating pin locations and calculating netlists for a circuit design tool.  Now I'd like you to
add functionality to parse hierarchical schematic sheets and generate a netlist for the entire schematic.


/* Begin of file: example_kicad_project.kicad_sch */
(kicad_sch
	(version 20231120)
	(generator "eeschema")
	(generator_version "8.0")
	(uuid "139408cf-b4ac-4ccf-8751-afbb6def1f13")
	(paper "A4")
	(lib_symbols)
	(sheet
		(at 36.83 48.26)
		(size 17.78 20.32)
		(fields_autoplaced yes)
		(stroke
			(width 0.1524)
			(type solid)
		)
		(fill
			(color 0 0 0 0.0000)
		)
		(uuid "7dcd522d-d03d-41f6-bad3-56f1f937b049")
		(property "Sheetname" "resistor_divider"
			(at 36.83 47.5484 0)
			(effects
				(font
					(size 1.27 1.27)
				)
				(justify left bottom)
			)
		)
		(property "Sheetfile" "resistor_divider.kicad_sch"
			(at 36.83 69.1646 0)
			(effects
				(font
					(size 1.27 1.27)
				)
				(justify left top)
			)
		)
		(pin "R1_2-R2_1" input
			(at 54.61 55.88 0)
			(effects
				(font
					(size 1.27 1.27)
				)
				(justify right)
			)
			(uuid "8d8ee59b-4d1a-4a57-9097-ba22b5e75d32")
		)
		(instances
			(project "example_kicad_project"
				(path "/139408cf-b4ac-4ccf-8751-afbb6def1f13"
					(page "3")
				)
			)
		)
	)
	(sheet
		(at 143.51 48.26)
		(size 13.97 21.59)
		(fields_autoplaced yes)
		(stroke
			(width 0.1524)
			(type solid)
		)
		(fill
			(color 0 0 0 0.0000)
		)
		(uuid "8234fcde-2a25-40ed-bf1a-aa4bf9bd93ad")
		(property "Sheetname" "wire_conn_test"
			(at 143.51 47.5484 0)
			(effects
				(font
					(size 1.27 1.27)
				)
				(justify left bottom)
			)
		)
		(property "Sheetfile" "wire_conn_test.kicad_sch"
			(at 143.51 70.4346 0)
			(effects
				(font
					(size 1.27 1.27)
				)
				(justify left top)
			)
		)
		(instances
			(project "example_kicad_project"
				(path "/139408cf-b4ac-4ccf-8751-afbb6def1f13"
					(page "5")
				)
			)
		)
	)
	(sheet
		(at 72.39 46.99)
		(size 22.86 21.59)
		(fields_autoplaced yes)
		(stroke
			(width 0.1524)
			(type solid)
		)
		(fill
			(color 0 0 0 0.0000)
		)
		(uuid "bb878e8b-3ef6-45c7-bc17-d62b28e24d94")
		(property "Sheetname" "power2"
			(at 72.39 46.2784 0)
			(effects
				(font
					(size 1.27 1.27)
				)
				(justify left bottom)
			)
		)
		(property "Sheetfile" "power2.kicad_sch"
			(at 72.39 69.1646 0)
			(effects
				(font
					(size 1.27 1.27)
				)
				(justify left top)
			)
		)
		(instances
			(project "example_kicad_project"
				(path "/139408cf-b4ac-4ccf-8751-afbb6def1f13"
					(page "2")
				)
			)
		)
	)
	(sheet
		(at 111.76 45.72)
		(size 21.59 25.4)
		(fields_autoplaced yes)
		(stroke
			(width 0.1524)
			(type solid)
		)
		(fill
			(color 0 0 0 0.0000)
		)
		(uuid "e6f5f316-cb92-4d26-9a5c-0bb6c841d4b0")
		(property "Sheetname" "stm32"
			(at 111.76 45.0084 0)
			(effects
				(font
					(size 1.27 1.27)
				)
				(justify left bottom)
			)
		)
		(property "Sheetfile" "stm32.kicad_sch"
			(at 111.76 71.7046 0)
			(effects
				(font
					(size 1.27 1.27)
				)
				(justify left top)
			)
		)
		(instances
			(project "example_kicad_project"
				(path "/139408cf-b4ac-4ccf-8751-afbb6def1f13"
					(page "4")
				)
			)
		)
	)
	(sheet_instances
		(path "/"
			(page "1")
		)
	)
)

/* End of file: example_kicad_project.kicad_sch */

/* Begin of file: kiutils_test.py */
from kiutils.schematic import Schematic
import math
import sys

def parse_labels(schematic):
    """
    Parse different types of labels from the schematic
    """
    labels = {
        'local': [],
        'hierarchical': [],
        'power': []
    }
    
    # Parse local labels
    for label in schematic.labels:
        label_info = {
            'text': label.text,
            'position': (label.position.X, label.position.Y),
            'angle': label.position.angle
        }
        labels['local'].append(label_info)
        
    # Parse hierarchical labels
    for label in schematic.hierarchicalLabels:
        label_info = {
            'text': label.text,
            'shape': label.shape,  # input/output/bidirectional/etc
            'position': (label.position.X, label.position.Y),
            'angle': label.position.angle
        }
        labels['hierarchical'].append(label_info)
    
    # Parse power symbols (they appear as schematic symbols)
    for symbol in schematic.schematicSymbols:
        if symbol.libraryNickname == 'power':
            if hasattr(symbol, 'properties'):
                # Find the Value property which contains the power net name
                value_prop = next((prop for prop in symbol.properties if prop.key == 'Value'), None)
                if value_prop:
                    label_info = {
                        'text': value_prop.value,
                        'position': (symbol.position.X, symbol.position.Y),
                        'angle': symbol.position.angle
                    }
                    labels['power'].append(label_info)

    return labels

def calculate_pin_position(component_position, pin_position, component_angle=0):
    """
    Calculate absolute pin position based on component position and relative pin position
    """
    angle_rad = math.radians(component_angle)
    
    # Apply rotation
    rotated_x = pin_position.X * math.cos(angle_rad) - pin_position.Y * math.sin(angle_rad)
    rotated_y = pin_position.X * math.sin(angle_rad) + pin_position.Y * math.cos(angle_rad)
    
    # Add component position
    absolute_x = component_position.X + rotated_x
    absolute_y = component_position.Y - rotated_y
    
    return (absolute_x, absolute_y)

def find_symbol_definition(schematic, lib_nickname, entry_name):
    """
    Find symbol definition from library symbols
    """
    for symbol in schematic.libSymbols:
        if (symbol.libraryNickname == lib_nickname and 
            symbol.entryName == entry_name):
            return symbol
    return None

def get_component_pins(schematic):
    """
    Extract and calculate absolute positions for all component pins in the schematic
    """
    component_pins = {}
    
    for component in schematic.schematicSymbols:
        symbol_def = find_symbol_definition(
            schematic, 
            component.libraryNickname, 
            component.entryName
        )
        
        if not symbol_def:
            continue
            
        pins = []
        for unit in symbol_def.units:
            if hasattr(unit, 'pins'):
                pins.extend(unit.pins)
        
        component_pins[component.properties[0].value] = []
        
        for pin in pins:
            absolute_pos = calculate_pin_position(
                component.position,
                pin.position,
                component.position.angle
            )
            pin_info = {
                'pin_number': pin.number,
                'pin_name': pin.name,
                'absolute_position': absolute_pos,
                'electrical_type': pin.electricalType
            }
            component_pins[component.properties[0].value].append(pin_info)
            
        component_pins[component.properties[0].value].sort(
            key=lambda x: int(x['pin_number'])
        )
    
    return component_pins

def get_wire_connections(schematic):
    """
    Extract wire connections from the schematic
    """
    wire_connections = []
    
    for item in schematic.graphicalItems:
        if hasattr(item, 'type') and item.type == 'wire':
            start_point = (float(item.points[0].X), float(item.points[0].Y))
            end_point = (float(item.points[1].X), float(item.points[1].Y))
            wire_connections.append((start_point, end_point))
    
    return wire_connections

def find_label_for_position(position, labels, wire_connections, tolerance=0.01):
    """
    Find a label that connects to the given position, either directly or through wires
    """
    # Helper function to check if points are close enough to be considered connected
    def points_match(p1, p2, tolerance=0.01):
        return (abs(p1[0] - p2[0]) <= tolerance and 
                abs(p1[1] - p2[1]) <= tolerance)
    
    # Helper function to get all connected points through wires
    def get_connected_points(start_pos, wire_list, visited=None):
        if visited is None:
            visited = set()
        
        connected_points = {start_pos}
        for wire in wire_list:
            wire_start = (wire[0][0], wire[0][1])
            wire_end = (wire[1][0], wire[1][1])
            
            if (wire_start, wire_end) in visited:
                continue
                
            visited.add((wire_start, wire_end))
            
            if points_match(start_pos, wire_start, tolerance):
                connected_points.add(wire_end)
                connected_points.update(
                    get_connected_points(wire_end, wire_list, visited)
                )
            elif points_match(start_pos, wire_end, tolerance):
                connected_points.add(wire_start)
                connected_points.update(
                    get_connected_points(wire_start, wire_list, visited)
                )
                
        return connected_points

    # Get all points connected to the given position
    connected_points = get_connected_points(position, wire_connections)
    
    # Check local labels
    for label in labels['local']:
        label_pos = (label['position'][0], label['position'][1])
        if any(points_match(label_pos, p, tolerance) for p in connected_points):
            return ('local', label['text'])
            
    # Check hierarchical labels
    for label in labels['hierarchical']:
        label_pos = (label['position'][0], label['position'][1])
        if any(points_match(label_pos, p, tolerance) for p in connected_points):
            return ('hierarchical', label['text'])
            
    # Check power labels
    for label in labels['power']:
        label_pos = (label['position'][0], label['position'][1])
        if any(points_match(label_pos, p, tolerance) for p in connected_points):
            return ('power', label['text'])
            
    return None

def calculate_pin_connectivity(component_pins, wire_connections, labels):
    """
    Calculate connectivity between pins and labels, properly handling local labels
    """
    netlist = {}
    net_counter = 1
    
    def are_points_connected(point1, point2, wire_list, local_labels, visited=None):
        if visited is None:
            visited = set()
            
        p1 = (round(point1[0], 2), round(point1[1], 2))
        p2 = (round(point2[0], 2), round(point2[1], 2))
        
        if p1 == p2:
            return True
        
        # Check if points share a local label
        label1 = find_label_for_position(p1, labels, wire_list)
        label2 = find_label_for_position(p2, labels, wire_list)
        
        if label1 and label2 and label1[1] == label2[1] and label1[0] == 'local':
            return True
            
        for wire in wire_list:
            wire_start = (round(wire[0][0], 2), round(wire[0][1], 2))
            wire_end = (round(wire[1][0], 2), round(wire[1][1], 2))
            
            wire_key = (wire_start, wire_end)
            if wire_key in visited:
                continue
                
            if p1 in (wire_start, wire_end):
                visited.add(wire_key)
                other_point = wire_end if p1 == wire_start else wire_start
                if are_points_connected(other_point, p2, wire_list, local_labels, visited):
                    return True
                    
        return False

    # Process pins and assign to nets
    unassigned_pins = []
    for component, pins in component_pins.items():
        for pin in pins:
            pin_position = pin['absolute_position']
            pin_info = {
                'component': component,
                'pin_number': pin['pin_number'],
                'pin_name': pin['pin_name'],
                'position': pin_position
            }
            unassigned_pins.append(pin_info)
    
    # Group pins into nets, including local label connections
    while unassigned_pins:
        current_pin = unassigned_pins.pop(0)
        current_net = [current_pin]
        
        # Check connectivity with remaining pins
        i = 0
        while i < len(unassigned_pins):
            test_pin = unassigned_pins[i]
            if are_points_connected(
                current_pin['position'],
                test_pin['position'],
                wire_connections,
                labels['local']
            ):
                current_net.append(test_pin)
                unassigned_pins.pop(i)
            else:
                i += 1
        
        # Look for a label connected to any pin in this net
        net_name = None
        for pin in current_net:
            label_info = find_label_for_position(
                pin['position'],
                labels,
                wire_connections
            )
            if label_info:
                label_type, label_text = label_info
                # Prioritize local labels
                if label_type == 'local':
                    net_name = label_text
                    break
                elif not net_name:  # Use other label types as fallback
                    net_name = label_text
                
        if net_name is None:
            net_name = f"NET_{net_counter}"
            net_counter += 1
            
        netlist[net_name] = current_net
    
    return netlist
def analyze_schematic(schematic):
    """
    Analyze schematic and print component pin positions, connectivity, and labels
    """
    # Get component pins
    component_pins = get_component_pins(schematic)
    
    # Get wire connections
    wire_connections = get_wire_connections(schematic)
    
    # Parse labels
    labels = parse_labels(schematic)
    
    # Calculate pin connectivity with label-based net names
    netlist = calculate_pin_connectivity(component_pins, wire_connections, labels)
    
    # Print results
    print("\n=== Component Pin Positions ===")
    for component_ref, pins in component_pins.items():
        print(f"\nComponent: {component_ref}")
        for pin in pins:
            print(f"  Pin {pin['pin_number']} ({pin['pin_name']}):")
            print(f"    Position: ({pin['absolute_position'][0]:.2f}, "
                  f"{pin['absolute_position'][1]:.2f})")
            print(f"    Type: {pin['electrical_type']}")
    
    print("\n=== Labels ===")
    print("\nLocal Labels:")
    for label in labels['local']:
        print(f"  {label['text']} at ({label['position'][0]:.2f}, {label['position'][1]:.2f})")
        
    print("\nHierarchical Labels:")
    for label in labels['hierarchical']:
        print(f"  {label['text']} ({label['shape']}) at ({label['position'][0]:.2f}, {label['position'][1]:.2f})")
        
    print("\nPower Labels:")
    for label in labels['power']:
        print(f"  {label['text']} at ({label['position'][0]:.2f}, {label['position'][1]:.2f})")
    
    print("\n=== Netlist ===")
    for net_name, connected_pins in netlist.items():
        print(f"\n{net_name}:")
        for pin in connected_pins:
            print(f"  {pin['component']} Pin {pin['pin_number']} ({pin['pin_name']})")


def main(file_path):
    # Load the schematic
    schematic = Schematic().from_file(file_path)
    print(f"Loaded schematic: {schematic}")
    
    # Analyze the schematic
    analyze_schematic(schematic)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: python kiutils_test.py <schematic_file_path>")
    else:
        main(sys.argv[1])
/* End of file: kiutils_test.py */
